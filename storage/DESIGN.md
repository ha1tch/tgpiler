# Storage Layer Design

## Overview

The storage layer provides a pluggable abstraction between transpiled business logic and data access. This allows the same Go code to work with different backends: gRPC (DSL), PostgreSQL, MySQL, SQLite, SQL Server, or mocks for testing.

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                  Transpiled Business Logic                  │
│                  (generated from T-SQL SPs)                 │
└─────────────────────────┬───────────────────────────────────┘
                          │ uses
                          ▼
              ┌───────────────────────┐
              │   Repository          │
              │   Interfaces          │
              │   (per entity/domain) │
              └───────────┬───────────┘
                          │ implemented by
        ┌────────┬────────┼────────┬────────┬────────┐
        ▼        ▼        ▼        ▼        ▼        ▼
   ┌────────┐┌───────┐┌───────┐┌───────┐┌───────┐┌──────┐
   │  gRPC  ││Postgre││ MySQL ││SQLite ││SQLSrvr││ Mock │
   │  (DSL) ││       ││       ││       ││       ││      │
   └────────┘└───────┘└───────┘└───────┘└───────┘└──────┘
```

## Core Interfaces

### 1. Operation Types

Operations detected from SQL statements map to these categories:

```go
type OperationType int

const (
    OpSelect OperationType = iota  // SELECT
    OpInsert                       // INSERT
    OpUpdate                       // UPDATE
    OpDelete                       // DELETE
    OpExec                         // EXEC (call another SP)
)
```

### 2. Field Optionality

Critical for NULL handling and proto mapping:

```go
type Optionality int

const (
    Required Optionality = iota  // Must have value, NOT NULL
    Optional                     // May be nil/NULL
    Computed                     // Generated by DB (auto-increment, defaults)
)
```

### 3. Field Descriptor

Describes a field in an operation:

```go
type Field struct {
    Name         string       // SQL column name
    GoName       string       // Go field name (PascalCase)
    GoType       string       // Go type: "int32", "*int32", "string", etc.
    SQLType      string       // Original SQL type
    Optionality  Optionality  
    ProtoField   string       // Mapped proto field (if gRPC backend)
    ProtoNumber  int          // Proto field number
}
```

### 4. Operation Descriptor

Describes a data operation detected in a stored procedure:

```go
type Operation struct {
    Type        OperationType
    Table       string           // Primary table
    Alias       string           // Table alias if used
    Fields      []Field          // Fields involved
    KeyFields   []Field          // WHERE clause fields (for Select/Update/Delete)
    ReturnType  string           // For Select: struct type returned
    Procedure   string           // Source SP name
    Line        int              // Line number in source
}
```

### 5. Repository Interface (Generated)

For each entity/table combination detected, generate a repository interface:

```go
// Example: generated from operations on Currency table
type CurrencyRepository interface {
    // From: SELECT currency_id, currency_name FROM Currency WHERE currency_code = @code
    GetByCode(ctx context.Context, code string) (*Currency, error)
    
    // From: SELECT * FROM Currency WHERE currency_id = @id
    GetByID(ctx context.Context, id int32) (*Currency, error)
    
    // From: INSERT INTO Currency (currency_code, currency_name) VALUES (@code, @name)
    Create(ctx context.Context, c *CurrencyCreate) (*Currency, error)
}
```

### 6. Unit of Work (Optional, for transactions)

```go
type UnitOfWork interface {
    Currency() CurrencyRepository
    Country() CountryRepository
    Transfer() TransferRepository
    // ...
    
    Begin(ctx context.Context) error
    Commit() error
    Rollback() error
}
```

## Backend Interface

Each backend implements a generator that produces repository implementations:

```go
type BackendGenerator interface {
    // Name returns the backend identifier (e.g., "postgres", "sqlite", "grpc")
    Name() string
    
    // Generate produces implementation files for detected operations
    Generate(ops []Operation, outputDir string) error
    
    // GenerateSchema produces schema creation (for SQL backends)
    GenerateSchema(ops []Operation, outputDir string) error
    
    // GenerateMocks produces mock implementations (for testing)
    GenerateMocks(ops []Operation, outputDir string) error
}
```

## Proto Mapping (for gRPC backend)

### Proto Field Info

```go
type ProtoFieldInfo struct {
    Name        string       // Proto field name
    Number      int          // Field number
    Type        string       // Proto type
    GoType      string       // Generated Go type
    IsOptional  bool         // Has 'optional' keyword
    IsRepeated  bool         // Is repeated field
    MessageType string       // If type is message, the message name
}

type ProtoMethodInfo struct {
    Name         string           // RPC method name
    Service      string           // Service name
    RequestType  string           // Request message type
    ResponseType string           // Response message type
    RequestFields  []ProtoFieldInfo
    ResponseFields []ProtoFieldInfo
}

type ProtoServiceInfo struct {
    Name    string
    Package string
    Methods []ProtoMethodInfo
}
```

### Matching SQL to Proto

The detector needs to match SQL operations to proto methods:

```go
type SQLToProtoMapping struct {
    Operation    Operation        // Detected SQL operation
    ProtoMethod  ProtoMethodInfo  // Matched proto method
    FieldMapping map[string]string // SQL field -> Proto field
    Confidence   float64          // Match confidence (0.0-1.0)
}
```

Matching heuristics:
1. Table name → Service name (Currency → CatalogService.GetCurrency*)
2. WHERE columns → Request fields
3. SELECT columns → Response fields
4. Operation type → Method prefix (SELECT → Get*, INSERT → Create*, etc.)

## Generated Code Structure

```
generated/
├── models/
│   ├── currency.go       # type Currency struct { ... }
│   ├── country.go
│   └── transfer.go
├── repositories/
│   ├── interfaces.go     # All repository interfaces
│   └── unit_of_work.go   # UnitOfWork interface
├── backends/
│   ├── postgres/
│   │   ├── currency_repo.go
│   │   ├── country_repo.go
│   │   └── unit_of_work.go
│   ├── sqlite/
│   │   ├── currency_repo.go
│   │   ├── schema.go
│   │   └── seed.go
│   ├── grpc/
│   │   ├── currency_repo.go  # Calls DSL CatalogService
│   │   └── client.go
│   └── mock/
│       ├── currency_repo.go
│       └── expectations.go
└── logic/
    ├── process_transfer.go   # Transpiled SP logic
    └── calculate_fee.go
```

## Example: Full Flow

### Input: T-SQL

```sql
CREATE PROCEDURE GetTransferDetails
    @ClaimNumber VARCHAR(50),
    @TransferInfo VARCHAR(MAX) OUTPUT,
    @Status INT OUTPUT
AS
BEGIN
    DECLARE @CurrencyCode VARCHAR(3)
    DECLARE @Amount DECIMAL(18,2)
    
    SELECT @Amount = origination_amount,
           @CurrencyCode = origination_currency
    FROM Transfer 
    WHERE claim_number = @ClaimNumber
    
    SELECT @TransferInfo = currency_name
    FROM Currency
    WHERE currency_code = @CurrencyCode
    
    SET @Status = 1
END
```

### Detected Operations

```go
[]Operation{
    {
        Type: OpSelect,
        Table: "Transfer",
        Fields: []Field{
            {Name: "origination_amount", GoType: "decimal.Decimal"},
            {Name: "origination_currency", GoType: "string"},
        },
        KeyFields: []Field{
            {Name: "claim_number", GoType: "string"},
        },
    },
    {
        Type: OpSelect,
        Table: "Currency",
        Fields: []Field{
            {Name: "currency_name", GoType: "string"},
        },
        KeyFields: []Field{
            {Name: "currency_code", GoType: "string"},
        },
    },
}
```

### Generated Interface

```go
type TransferRepository interface {
    GetByClaimNumber(ctx context.Context, claimNumber string) (*TransferBasic, error)
}

type CurrencyRepository interface {
    GetByCode(ctx context.Context, code string) (*Currency, error)
}

type TransferBasic struct {
    OriginationAmount   decimal.Decimal
    OriginationCurrency string
}
```

### Generated Logic (calls interfaces)

```go
func GetTransferDetails(
    ctx context.Context,
    repos *Repositories,
    claimNumber string,
) (transferInfo string, status int32, err error) {
    
    transfer, err := repos.Transfer.GetByClaimNumber(ctx, claimNumber)
    if err != nil {
        return "", 0, err
    }
    
    currency, err := repos.Currency.GetByCode(ctx, transfer.OriginationCurrency)
    if err != nil {
        return "", 0, err
    }
    
    transferInfo = currency.CurrencyName
    status = 1
    
    return transferInfo, status, nil
}
```

### Generated gRPC Backend

```go
func (r *grpcCurrencyRepo) GetByCode(ctx context.Context, code string) (*Currency, error) {
    resp, err := r.client.GetCurrencyByCode(ctx, &dsl.GetCurrencyByCodeRequest{
        CurrencyCode: code,
    })
    if err != nil {
        return nil, err
    }
    return &Currency{
        ID:   resp.Currency.CurrencyId,
        Code: resp.Currency.CurrencyCode,
        Name: resp.Currency.CurrencyName,
    }, nil
}
```

### Generated SQLite Backend

```go
func (r *sqliteCurrencyRepo) GetByCode(ctx context.Context, code string) (*Currency, error) {
    var c Currency
    err := r.db.QueryRowContext(ctx,
        `SELECT currency_id, currency_code, currency_name 
         FROM Currency WHERE currency_code = ?`, code).
        Scan(&c.ID, &c.Code, &c.Name)
    if err == sql.ErrNoRows {
        return nil, ErrNotFound
    }
    return &c, err
}
```

## Optionality Handling

### In SQL

```sql
-- @BeneficiaryMiddleName might be NULL
SELECT beneficiary_first_name, beneficiary_middle_name
FROM Beneficiary WHERE id = @Id
```

### Detected

```go
Field{
    Name: "beneficiary_middle_name",
    GoType: "*string",  // Pointer because nullable
    Optionality: Optional,
}
```

### In Proto (from DSL)

```protobuf
message Beneficiary {
    string beneficiary_first_name = 1;
    optional string beneficiary_middle_name = 2;  // Optional!
}
```

### Generated Model

```go
type Beneficiary struct {
    FirstName  string   // Required
    MiddleName *string  // Optional - pointer
}
```

### Backend Handling

```go
// SQLite
func (r *sqliteBeneficiaryRepo) GetByID(ctx context.Context, id int32) (*Beneficiary, error) {
    var b Beneficiary
    var middleName sql.NullString
    
    err := r.db.QueryRowContext(ctx,
        `SELECT beneficiary_first_name, beneficiary_middle_name FROM Beneficiary WHERE id = ?`, id).
        Scan(&b.FirstName, &middleName)
    
    if middleName.Valid {
        b.MiddleName = &middleName.String
    }
    return &b, err
}

// gRPC
func (r *grpcBeneficiaryRepo) GetByID(ctx context.Context, id int32) (*Beneficiary, error) {
    resp, err := r.client.GetBeneficiary(ctx, &dsl.GetBeneficiaryRequest{Id: id})
    if err != nil {
        return nil, err
    }
    
    b := &Beneficiary{
        FirstName: resp.BeneficiaryFirstName,
    }
    if resp.BeneficiaryMiddleName != nil {
        b.MiddleName = resp.BeneficiaryMiddleName  // Already *string from proto
    }
    return b, nil
}
```

## Next Steps

1. Implement `storage/types.go` - Core type definitions
2. Implement `storage/detector.go` - SQL operation detection
3. Implement `storage/proto_parser.go` - Proto file parsing with optionality
4. Implement `storage/matcher.go` - SQL to Proto matching
5. Implement backend generators one by one
