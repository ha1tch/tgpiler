// Package storage provides abstractions for the data access layer.
// It allows transpiled business logic to work with different backends:
// gRPC (DSL), PostgreSQL, MySQL, SQLite, SQL Server, or mocks.
package storage

import (
	"context"
)

// OperationType represents the type of SQL operation detected.
type OperationType int

const (
	OpSelect   OperationType = iota // SELECT statement
	OpInsert                        // INSERT statement
	OpUpdate                        // UPDATE statement
	OpDelete                        // DELETE statement
	OpExec                          // EXEC/EXECUTE (call another procedure)
	OpTruncate                      // TRUNCATE TABLE statement
)

func (o OperationType) String() string {
	switch o {
	case OpSelect:
		return "SELECT"
	case OpInsert:
		return "INSERT"
	case OpUpdate:
		return "UPDATE"
	case OpDelete:
		return "DELETE"
	case OpExec:
		return "EXEC"
	case OpTruncate:
		return "TRUNCATE"
	default:
		return "UNKNOWN"
	}
}

// Optionality indicates whether a field is required, optional, or computed.
type Optionality int

const (
	Required Optionality = iota // Field must have a value (NOT NULL)
	Optional                    // Field may be nil/NULL
	Computed                    // Field is generated by DB (auto-increment, default, etc.)
)

func (o Optionality) String() string {
	switch o {
	case Required:
		return "required"
	case Optional:
		return "optional"
	case Computed:
		return "computed"
	default:
		return "unknown"
	}
}

// Field describes a field/column in a data operation.
type Field struct {
	// SQL metadata
	Name    string // SQL column name (e.g., "currency_code")
	SQLType string // Original SQL type (e.g., "VARCHAR(50)")

	// Go mapping
	GoName string // Go field name in PascalCase (e.g., "CurrencyCode")
	GoType string // Go type (e.g., "string", "*string", "int32", "decimal.Decimal")

	// Optionality
	Optionality Optionality

	// Proto mapping (for gRPC backend)
	ProtoField  string // Proto field name (e.g., "currency_code")
	ProtoNumber int    // Proto field number

	// Context
	IsKey      bool // Is this field part of a key/WHERE clause?
	IsAssigned bool // Is this field being assigned to a variable?
	Variable   string // T-SQL variable being assigned (e.g., "@CurrencyCode")
}

// Operation describes a data operation detected in a stored procedure.
type Operation struct {
	// Operation details
	Type  OperationType
	Table string // Primary table name
	Alias string // Table alias (if used)

	// Fields involved
	Fields    []Field // SELECT columns or INSERT/UPDATE fields
	KeyFields []Field // WHERE clause fields

	// For INSERT with OUTPUT or SELECT INTO
	OutputFields []Field

	// Source tracking
	Procedure string // Source stored procedure name
	Line      int    // Line number in source SQL
	RawSQL    string // Original SQL statement (for reference)

	// For EXEC operations
	CalledProcedure string   // Name of called procedure
	Parameters      []Field  // Parameters passed to called procedure
}

// Model describes a generated Go struct for an entity.
type Model struct {
	Name       string  // Go struct name (e.g., "Currency")
	Table      string  // Source table name
	Fields     []Field
	PrimaryKey []Field // Primary key fields
}

// RepositoryMethod describes a method on a repository interface.
type RepositoryMethod struct {
	Name        string  // Method name (e.g., "GetByCode")
	Operation   Operation
	InputFields []Field // Method parameters
	OutputType  string  // Return type (e.g., "*Currency", "[]Currency")
	ReturnsMany bool    // Returns slice vs single entity
}

// Repository describes a repository interface for an entity.
type Repository struct {
	Name    string             // Interface name (e.g., "CurrencyRepository")
	Entity  string             // Entity name (e.g., "Currency")
	Table   string             // Source table
	Methods []RepositoryMethod
}

// UnitOfWorkSpec describes the unit of work interface.
type UnitOfWorkSpec struct {
	Repositories []Repository
	HasTransactions bool
}

// BackendType identifies the storage backend.
type BackendType string

const (
	BackendGRPC      BackendType = "grpc"
	BackendPostgres  BackendType = "postgres"
	BackendMySQL     BackendType = "mysql"
	BackendSQLite    BackendType = "sqlite"
	BackendSQLServer BackendType = "sqlserver"
	BackendOracle    BackendType = "oracle"
	BackendMock      BackendType = "mock"
)

// BackendConfig holds configuration for a backend generator.
type BackendConfig struct {
	Type       BackendType
	OutputDir  string
	Package    string
	
	// For gRPC backend
	ProtoFiles []string
	ProtoPackage string
	
	// For SQL backends
	ConnectionString string
	
	// Generation options
	GenerateSchema bool
	GenerateSeed   bool
	GenerateMocks  bool
	GenerateTests  bool
}

// BackendGenerator is implemented by each backend to generate code.
type BackendGenerator interface {
	// Name returns the backend identifier.
	Name() BackendType
	
	// Generate produces repository implementation files.
	Generate(ctx context.Context, spec *GenerationSpec) error
}

// GenerationSpec contains everything needed to generate backend code.
type GenerationSpec struct {
	// Source info
	SourceFiles []string // Original .sql files
	
	// Detected operations
	Operations []Operation
	
	// Generated models
	Models []Model
	
	// Generated repositories
	Repositories []Repository
	
	// Proto info (for gRPC backend)
	ProtoServices []ProtoServiceInfo
	
	// SQL to Proto mappings (for gRPC backend)
	ProtoMappings []SQLToProtoMapping
	
	// Configuration
	Config BackendConfig
}

// Error types for repositories
type RepositoryError struct {
	Op      string // Operation that failed
	Entity  string // Entity type
	Key     string // Key value (if applicable)
	Err     error  // Underlying error
}

func (e *RepositoryError) Error() string {
	if e.Key != "" {
		return e.Op + " " + e.Entity + " [" + e.Key + "]: " + e.Err.Error()
	}
	return e.Op + " " + e.Entity + ": " + e.Err.Error()
}

func (e *RepositoryError) Unwrap() error {
	return e.Err
}

// Common errors
var (
	ErrNotFound      = &RepositoryError{Op: "find", Err: errNotFound}
	ErrAlreadyExists = &RepositoryError{Op: "create", Err: errAlreadyExists}
	ErrInvalidInput  = &RepositoryError{Op: "validate", Err: errInvalidInput}
)

type errorString string

func (e errorString) Error() string { return string(e) }

const (
	errNotFound      errorString = "not found"
	errAlreadyExists errorString = "already exists"
	errInvalidInput  errorString = "invalid input"
)
