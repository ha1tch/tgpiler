package protogen

import (
	"bytes"
	"fmt"
	"io"
	"strings"
	"text/template"

	"github.com/ha1tch/tgpiler/storage"
)

// ImplementationGenerator generates complete repository implementations.
type ImplementationGenerator struct {
	proto      *storage.ProtoParseResult
	procedures []*storage.Procedure
	mapper     *storage.ProtoToSQLMapper
	mappings   map[string]*storage.MethodMapping
}

// NewImplementationGenerator creates a generator with proto-to-SQL mappings.
func NewImplementationGenerator(proto *storage.ProtoParseResult, procedures []*storage.Procedure) *ImplementationGenerator {
	mapper := storage.NewProtoToSQLMapper(proto, procedures)
	mappings := mapper.MapAll()

	return &ImplementationGenerator{
		proto:      proto,
		procedures: procedures,
		mapper:     mapper,
		mappings:   mappings,
	}
}

// GetStats returns mapping statistics.
func (g *ImplementationGenerator) GetStats() storage.MappingStats {
	return g.mapper.GetStats()
}

// GenerateServiceImpl generates a complete service implementation file.
func (g *ImplementationGenerator) GenerateServiceImpl(serviceName string, opts ServerGenOptions, w io.Writer) error {
	svc := g.proto.AllServices[serviceName]
	if svc == nil {
		return fmt.Errorf("service not found: %s", serviceName)
	}

	data := implTemplateData{
		PackageName: opts.PackageName,
		ServiceName: serviceName,
		RepoName:    serviceName + "Repository",
		Imports:     make(map[string]bool),
	}

	// Standard imports
	data.Imports["context"] = true
	data.Imports["database/sql"] = true
	data.Imports["fmt"] = true

	// Build method data
	for _, method := range svc.Methods {
		key := serviceName + "." + method.Name
		mapping := g.mappings[key]

		md := implMethodData{
			MethodName:   method.Name,
			RequestType:  method.RequestType,
			ResponseType: method.ResponseType,
		}

		if mapping != nil && mapping.Procedure != nil {
			md.HasMapping = true
			md.ProcName = mapping.Procedure.Name
			md.Confidence = mapping.Confidence
			md.MatchReason = mapping.MatchReason
			md.ParamMappings = mapping.ParamMappings
			md.ResultMapping = mapping.ResultMapping

			// Check if we need time import
			for _, pm := range mapping.ParamMappings {
				if pm.GoType == "time.Time" {
					data.Imports["time"] = true
				}
			}
			if mapping.ResultMapping != nil {
				for _, fm := range mapping.ResultMapping.FieldMappings {
					if fm.GoType == "time.Time" {
						data.Imports["time"] = true
					}
				}
			}
		}

		data.Methods = append(data.Methods, md)
	}

	return implFileTemplate.Execute(w, data)
}

type implTemplateData struct {
	PackageName string
	ServiceName string
	RepoName    string
	Imports     map[string]bool
	Methods     []implMethodData
}

type implMethodData struct {
	MethodName    string
	RequestType   string
	ResponseType  string
	HasMapping    bool
	ProcName      string
	Confidence    float64
	MatchReason   string
	ParamMappings []storage.ParamMapping
	ResultMapping *storage.ResultMapping
}

var implFileTemplate = template.Must(template.New("impl").Funcs(template.FuncMap{
	"join": strings.Join,
	"lower": strings.ToLower,
	"hasPrefix": strings.HasPrefix,
	"trimPrefix": strings.TrimPrefix,
	"percent": func(f float64) string { return fmt.Sprintf("%.0f%%", f*100) },
	"sortedImports": func(imports map[string]bool) []string {
		var result []string
		// Standard library first
		std := []string{"context", "database/sql", "fmt", "time"}
		for _, s := range std {
			if imports[s] {
				result = append(result, s)
			}
		}
		return result
	},
	"genParams": func(mappings []storage.ParamMapping) string {
		var parts []string
		for _, pm := range mappings {
			if pm.ProtoField != "" {
				parts = append(parts, fmt.Sprintf("@%s", pm.ProcParam))
			} else if pm.HasDefault {
				continue // Skip params with defaults if no proto field
			} else {
				parts = append(parts, fmt.Sprintf("@%s", pm.ProcParam))
			}
		}
		return strings.Join(parts, ", ")
	},
	"genParamArgs": func(mappings []storage.ParamMapping) string {
		var parts []string
		for _, pm := range mappings {
			if pm.ProtoField != "" {
				parts = append(parts, fmt.Sprintf("req.%s", toGoFieldName(pm.ProtoField)))
			} else if pm.HasDefault {
				continue
			} else {
				parts = append(parts, "nil")
			}
		}
		return strings.Join(parts, ", ")
	},
	"genScanFields": func(rm *storage.ResultMapping) string {
		if rm == nil {
			return ""
		}
		var parts []string
		for _, fm := range rm.FieldMappings {
			if fm.ProtoField != "" {
				parts = append(parts, fmt.Sprintf("&result.%s", toGoFieldName(fm.ProtoField)))
			}
		}
		return strings.Join(parts, ", ")
	},
	"hasResultMapping": func(rm *storage.ResultMapping) bool {
		return rm != nil && len(rm.FieldMappings) > 0
	},
	"goFieldName": toGoFieldName,
}).Parse(`// Code generated by tgpiler. DO NOT EDIT.
// Source: proto definitions + stored procedures

package {{.PackageName}}

import (
{{- range sortedImports .Imports}}
	"{{.}}"
{{- end}}
)

// ============================================================================
// {{.ServiceName}} Repository Implementation
// ============================================================================

// {{.RepoName}} defines the data access interface for {{.ServiceName}}.
type {{.RepoName}} interface {
{{- range .Methods}}
	{{.MethodName}}(ctx context.Context, req *{{.RequestType}}) (*{{.ResponseType}}, error)
{{- end}}
}

// {{.RepoName}}SQL implements {{.RepoName}} using stored procedures.
type {{.RepoName}}SQL struct {
	db *sql.DB
}

// New{{.RepoName}}SQL creates a new SQL repository.
func New{{.RepoName}}SQL(db *sql.DB) *{{.RepoName}}SQL {
	return &{{.RepoName}}SQL{db: db}
}

{{range .Methods}}
// {{.MethodName}} implements the {{.MethodName}} operation.
{{- if .HasMapping}}
// Mapped to: {{.ProcName}} (confidence: {{percent .Confidence}}, {{.MatchReason}})
func (r *{{$.RepoName}}SQL) {{.MethodName}}(ctx context.Context, req *{{.RequestType}}) (*{{.ResponseType}}, error) {
	{{- if hasResultMapping .ResultMapping}}
	// Execute stored procedure and scan results
	query := "EXEC {{.ProcName}} {{genParams .ParamMappings}}"
	row := r.db.QueryRowContext(ctx, query, {{genParamArgs .ParamMappings}})
	
	var result {{trimPrefix .ResponseType "Get"}}
	err := row.Scan({{genScanFields .ResultMapping}})
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("{{.MethodName}}: not found")
		}
		return nil, fmt.Errorf("{{.MethodName}}: %w", err)
	}
	
	return &{{.ResponseType}}{
		{{- if hasPrefix .ResponseType "Get"}}
		{{trimPrefix (trimPrefix .ResponseType "Get") "Response"}}: &result,
		{{- end}}
	}, nil
	{{- else}}
	// Execute stored procedure (no result mapping)
	query := "EXEC {{.ProcName}} {{genParams .ParamMappings}}"
	_, err := r.db.ExecContext(ctx, query, {{genParamArgs .ParamMappings}})
	if err != nil {
		return nil, fmt.Errorf("{{.MethodName}}: %w", err)
	}
	
	return &{{.ResponseType}}{}, nil
	{{- end}}
}
{{- else}}
// WARNING: No stored procedure mapping found
func (r *{{$.RepoName}}SQL) {{.MethodName}}(ctx context.Context, req *{{.RequestType}}) (*{{.ResponseType}}, error) {
	// TODO: Implement - no matching stored procedure found
	// Consider creating a stored procedure or implementing inline SQL
	return nil, fmt.Errorf("{{.MethodName}}: not implemented - no stored procedure mapping")
}
{{- end}}

{{end}}
// ============================================================================
// {{.ServiceName}} Server
// ============================================================================

// {{.ServiceName}}Server implements the {{.ServiceName}} gRPC service.
type {{.ServiceName}}Server struct {
	repo {{.RepoName}}
}

// New{{.ServiceName}}Server creates a new server.
func New{{.ServiceName}}Server(repo {{.RepoName}}) *{{.ServiceName}}Server {
	return &{{.ServiceName}}Server{repo: repo}
}

{{range .Methods}}
// {{.MethodName}} handles the {{.MethodName}} RPC.
func (s *{{$.ServiceName}}Server) {{.MethodName}}(ctx context.Context, req *{{.RequestType}}) (*{{.ResponseType}}, error) {
	return s.repo.{{.MethodName}}(ctx, req)
}
{{end}}
`))

func toGoFieldName(name string) string {
	// Convert snake_case to PascalCase
	parts := strings.Split(name, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	result := strings.Join(parts, "")
	
	// Handle common abbreviations
	result = strings.ReplaceAll(result, "Id", "ID")
	result = strings.ReplaceAll(result, "Url", "URL")
	result = strings.ReplaceAll(result, "Sku", "SKU")
	
	return result
}

// GenerateAll generates implementation files for all services.
func (g *ImplementationGenerator) GenerateAll(outputDir string, opts ServerGenOptions) error {
	for svcName := range g.proto.AllServices {
		opts.PackageName = strings.ToLower(strings.TrimSuffix(svcName, "Service"))
		
		var buf bytes.Buffer
		if err := g.GenerateServiceImpl(svcName, opts, &buf); err != nil {
			return fmt.Errorf("generate %s: %w", svcName, err)
		}
		
		// Write would happen here with file I/O
		// For now, we just collect the output
	}
	return nil
}
