package protogen

import (
	"bytes"
	"fmt"
	"io"
	"strings"
	"text/template"

	"github.com/ha1tch/tgpiler/storage"
)

// ServerGenerator generates Go server implementation code from proto definitions.
type ServerGenerator struct {
	proto       *storage.ProtoParseResult
	packageName string
	imports     map[string]bool
}

// ServerGenOptions configures server generation.
type ServerGenOptions struct {
	PackageName     string // Go package name for generated code
	IncludeComments bool   // Include method comments
	UseContext      bool   // Include context.Context in method signatures
	GenerateMocks   bool   // Also generate mock implementations
	OutputDir       string // Output directory
}

// DefaultServerGenOptions returns sensible defaults.
func DefaultServerGenOptions() ServerGenOptions {
	return ServerGenOptions{
		PackageName:     "server",
		IncludeComments: true,
		UseContext:      true,
		GenerateMocks:   false,
	}
}

// NewServerGenerator creates a server generator.
func NewServerGenerator(proto *storage.ProtoParseResult, opts ServerGenOptions) *ServerGenerator {
	if opts.PackageName == "" {
		opts.PackageName = "server"
	}
	return &ServerGenerator{
		proto:       proto,
		packageName: opts.PackageName,
		imports:     make(map[string]bool),
	}
}

// GenerateService generates server implementation for a service.
func (g *ServerGenerator) GenerateService(serviceName string, w io.Writer) error {
	svc := g.proto.AllServices[serviceName]
	if svc == nil {
		return fmt.Errorf("service not found: %s", serviceName)
	}

	return g.generateServiceCode(svc, w)
}

// GenerateAll generates server implementations for all services.
func (g *ServerGenerator) GenerateAll(w io.Writer) error {
	var buf bytes.Buffer

	// Write header
	buf.WriteString(fmt.Sprintf("// Code generated by tgpiler. DO NOT EDIT.\n\n"))
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.packageName))

	// Collect all imports
	g.imports["context"] = true
	g.imports["fmt"] = true

	// Generate each service
	var serviceBufs []bytes.Buffer
	for _, svc := range g.proto.AllServices {
		var sbuf bytes.Buffer
		if err := g.generateServiceCode(svc, &sbuf); err != nil {
			return fmt.Errorf("generate %s: %w", svc.Name, err)
		}
		serviceBufs = append(serviceBufs, sbuf)
	}

	// Write imports
	buf.WriteString("import (\n")
	for imp := range g.imports {
		buf.WriteString(fmt.Sprintf("\t%q\n", imp))
	}
	buf.WriteString(")\n\n")

	// Write services
	for _, sbuf := range serviceBufs {
		buf.Write(sbuf.Bytes())
		buf.WriteString("\n")
	}

	_, err := w.Write(buf.Bytes())
	return err
}

func (g *ServerGenerator) generateServiceCode(svc *storage.ProtoServiceInfo, w io.Writer) error {
	data := serviceTemplateData{
		ServiceName:    svc.Name,
		ServiceComment: svc.Comment,
		Methods:        make([]methodTemplateData, 0, len(svc.Methods)),
	}

	for _, method := range svc.Methods {
		md := methodTemplateData{
			MethodName:     method.Name,
			RequestType:    method.RequestType,
			ResponseType:   method.ResponseType,
			Comment:        method.Comment,
			OperationType:  opTypeToString(method.InferredOp),
			IsStreaming:    method.ClientStreaming || method.ServerStreaming,
			ClientStream:   method.ClientStreaming,
			ServerStream:   method.ServerStreaming,
		}
		data.Methods = append(data.Methods, md)
	}

	return serviceTemplate.Execute(w, data)
}

type serviceTemplateData struct {
	ServiceName    string
	ServiceComment string
	Methods        []methodTemplateData
}

type methodTemplateData struct {
	MethodName    string
	RequestType   string
	ResponseType  string
	Comment       string
	OperationType string
	IsStreaming   bool
	ClientStream  bool
	ServerStream  bool
}

func opTypeToString(op storage.OperationType) string {
	switch op {
	case storage.OpSelect:
		return "SELECT"
	case storage.OpInsert:
		return "INSERT"
	case storage.OpUpdate:
		return "UPDATE"
	case storage.OpDelete:
		return "DELETE"
	default:
		return "EXEC"
	}
}

var serviceTemplate = template.Must(template.New("service").Funcs(template.FuncMap{
	"lower": strings.ToLower,
	"title": strings.Title,
}).Parse(`
// ============================================================================
// {{.ServiceName}} Server Implementation
// ============================================================================

// {{.ServiceName}}Server implements the {{.ServiceName}} gRPC service.
type {{.ServiceName}}Server struct {
	// Repository provides data access
	repo {{.ServiceName}}Repository

	// Add custom dependencies here
}

// New{{.ServiceName}}Server creates a new {{.ServiceName}}Server.
func New{{.ServiceName}}Server(repo {{.ServiceName}}Repository) *{{.ServiceName}}Server {
	return &{{.ServiceName}}Server{
		repo: repo,
	}
}
{{range .Methods}}
{{if .Comment}}// {{.MethodName}} - {{.Comment}}{{else}}// {{.MethodName}} handles the {{.MethodName}} RPC.{{end}}
{{- if .IsStreaming}}
// This is a streaming method.
{{- end}}
func (s *{{$.ServiceName}}Server) {{.MethodName}}(ctx context.Context, req *{{.RequestType}}) (*{{.ResponseType}}, error) {
	// Delegate to repository
	return s.repo.{{.MethodName}}(ctx, req)
}
{{end}}
`))

// ============================================================================
// Repository Generator
// ============================================================================

// RepositoryGenerator generates repository interface and implementation stubs.
type RepositoryGenerator struct {
	proto       *storage.ProtoParseResult
	packageName string
}

// NewRepositoryGenerator creates a repository generator.
func NewRepositoryGenerator(proto *storage.ProtoParseResult, packageName string) *RepositoryGenerator {
	return &RepositoryGenerator{
		proto:       proto,
		packageName: packageName,
	}
}

// GenerateInterface generates the repository interface.
func (g *RepositoryGenerator) GenerateInterface(serviceName string, w io.Writer) error {
	svc := g.proto.AllServices[serviceName]
	if svc == nil {
		return fmt.Errorf("service not found: %s", serviceName)
	}

	return repoInterfaceTemplate.Execute(w, g.buildRepoData(svc))
}

// GenerateStub generates a stub implementation.
func (g *RepositoryGenerator) GenerateStub(serviceName string, w io.Writer) error {
	svc := g.proto.AllServices[serviceName]
	if svc == nil {
		return fmt.Errorf("service not found: %s", serviceName)
	}

	return repoStubTemplate.Execute(w, g.buildRepoData(svc))
}

// GenerateSQLImpl generates a SQL-based implementation.
func (g *RepositoryGenerator) GenerateSQLImpl(serviceName string, w io.Writer) error {
	svc := g.proto.AllServices[serviceName]
	if svc == nil {
		return fmt.Errorf("service not found: %s", serviceName)
	}

	return repoSQLTemplate.Execute(w, g.buildRepoData(svc))
}

type repoTemplateData struct {
	PackageName string
	ServiceName string
	RepoName    string
	Methods     []repoMethodData
}

type repoMethodData struct {
	MethodName    string
	RequestType   string
	ResponseType  string
	OperationType string
	TableName     string
	Comment       string
}

func (g *RepositoryGenerator) buildRepoData(svc *storage.ProtoServiceInfo) repoTemplateData {
	data := repoTemplateData{
		PackageName: g.packageName,
		ServiceName: svc.Name,
		RepoName:    svc.Name + "Repository",
	}

	for _, method := range svc.Methods {
		md := repoMethodData{
			MethodName:    method.Name,
			RequestType:   method.RequestType,
			ResponseType:  method.ResponseType,
			OperationType: opTypeToString(method.InferredOp),
			TableName:     inferTableFromMethod(&method),
			Comment:       method.Comment,
		}
		data.Methods = append(data.Methods, md)
	}

	return data
}

func inferTableFromMethod(method *storage.ProtoMethodInfo) string {
	name := method.Name

	// Remove verb prefixes
	for _, prefix := range []string{
		"Get", "List", "Create", "Update", "Delete", "Find", "Search",
		"Add", "Remove", "Clear", "Validate", "Process", "Refresh",
		"Change", "Deactivate", "Verify", "Register", "Login", "Logout",
		"Reserve", "Release", "Adjust", "Set", "Vote", "Moderate",
	} {
		if strings.HasPrefix(name, prefix) {
			name = name[len(prefix):]
			break
		}
	}

	// Remove common suffixes
	for _, suffix := range []string{
		"ById", "ByID", "ByEmail", "BySlug", "BySku", "ByNumber", "ByCode",
		"ToCart", "FromCart", "Item", "Items", "Level", "Levels",
		"Status", "Token", "Code", "Password", "Email", "Summary",
		"Point", "Stock", "Pending",
	} {
		if strings.HasSuffix(name, suffix) {
			name = name[:len(name)-len(suffix)]
			break
		}
	}

	// Handle empty result by falling back to method name
	if name == "" {
		// Use the response type without "Response" suffix
		name = strings.TrimSuffix(method.ResponseType, "Response")
	}

	return name
}

var repoInterfaceTemplate = template.Must(template.New("repo_interface").Parse(`
// {{.RepoName}} defines the data access interface for {{.ServiceName}}.
type {{.RepoName}} interface {
{{- range .Methods}}
	// {{.MethodName}} performs a {{.OperationType}} operation on {{.TableName}}.
	{{.MethodName}}(ctx context.Context, req *{{.RequestType}}) (*{{.ResponseType}}, error)
{{- end}}
}
`))

var repoStubTemplate = template.Must(template.New("repo_stub").Parse(`
// {{.RepoName}}Stub is a stub implementation of {{.RepoName}}.
type {{.RepoName}}Stub struct{}

// New{{.RepoName}}Stub creates a new stub repository.
func New{{.RepoName}}Stub() *{{.RepoName}}Stub {
	return &{{.RepoName}}Stub{}
}
{{range .Methods}}
// {{.MethodName}} is a stub implementation.
func (r *{{$.RepoName}}Stub) {{.MethodName}}(ctx context.Context, req *{{.RequestType}}) (*{{.ResponseType}}, error) {
	return nil, fmt.Errorf("{{.MethodName}}: not implemented")
}
{{end}}
`))

var repoSQLTemplate = template.Must(template.New("repo_sql").Parse(`
// {{.RepoName}}SQL implements {{.RepoName}} using SQL.
type {{.RepoName}}SQL struct {
	db *sql.DB
}

// New{{.RepoName}}SQL creates a new SQL repository.
func New{{.RepoName}}SQL(db *sql.DB) *{{.RepoName}}SQL {
	return &{{.RepoName}}SQL{db: db}
}
{{range .Methods}}
// {{.MethodName}} implements the {{.OperationType}} operation on {{.TableName}}.
func (r *{{$.RepoName}}SQL) {{.MethodName}}(ctx context.Context, req *{{.RequestType}}) (*{{.ResponseType}}, error) {
	{{- if eq .OperationType "SELECT"}}
	// TODO: Implement SELECT query
	// query := "SELECT ... FROM {{.TableName}} WHERE ..."
	{{- else if eq .OperationType "INSERT"}}
	// TODO: Implement INSERT query
	// query := "INSERT INTO {{.TableName}} (...) VALUES (...)"
	{{- else if eq .OperationType "UPDATE"}}
	// TODO: Implement UPDATE query
	// query := "UPDATE {{.TableName}} SET ... WHERE ..."
	{{- else if eq .OperationType "DELETE"}}
	// TODO: Implement DELETE query
	// query := "DELETE FROM {{.TableName}} WHERE ..."
	{{- else}}
	// TODO: Implement custom operation
	{{- end}}
	return nil, fmt.Errorf("{{.MethodName}}: not implemented")
}
{{end}}
`))

// ============================================================================
// Full File Generator
// ============================================================================

// GenerateFile generates a complete Go file with service and repository.
func GenerateFile(proto *storage.ProtoParseResult, serviceName string, opts ServerGenOptions, w io.Writer) error {
	svc := proto.AllServices[serviceName]
	if svc == nil {
		return fmt.Errorf("service not found: %s", serviceName)
	}

	var buf bytes.Buffer

	// Header
	buf.WriteString("// Code generated by tgpiler. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", opts.PackageName))

	// Imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"database/sql\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString(")\n\n")

	// Generate server
	sg := NewServerGenerator(proto, opts)
	if err := sg.GenerateService(serviceName, &buf); err != nil {
		return err
	}

	// Generate repository interface and implementations
	rg := NewRepositoryGenerator(proto, opts.PackageName)
	if err := rg.GenerateInterface(serviceName, &buf); err != nil {
		return err
	}
	if err := rg.GenerateStub(serviceName, &buf); err != nil {
		return err
	}
	if err := rg.GenerateSQLImpl(serviceName, &buf); err != nil {
		return err
	}

	_, err := w.Write(buf.Bytes())
	return err
}
