// Code generated by tgpiler. DO NOT EDIT.
// Source: proto definitions + stored procedures

package user

import (
	"context"
	"database/sql"
	"fmt"
	"time"
)

// ============================================================================
// UserService Repository Implementation
// ============================================================================

// UserServiceRepository defines the data access interface for UserService.
type UserServiceRepository interface {
	Register(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error)
	Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error)
	RefreshToken(ctx context.Context, req *RefreshTokenRequest) (*RefreshTokenResponse, error)
	VerifyEmail(ctx context.Context, req *VerifyEmailRequest) (*VerifyEmailResponse, error)
	GetUser(ctx context.Context, req *GetUserRequest) (*GetUserResponse, error)
	GetUserByEmail(ctx context.Context, req *GetUserByEmailRequest) (*GetUserByEmailResponse, error)
	UpdateUser(ctx context.Context, req *UpdateUserRequest) (*UpdateUserResponse, error)
	ChangePassword(ctx context.Context, req *ChangePasswordRequest) (*ChangePasswordResponse, error)
	DeactivateUser(ctx context.Context, req *DeactivateUserRequest) (*DeactivateUserResponse, error)
}

// UserServiceRepositorySQL implements UserServiceRepository using stored procedures.
type UserServiceRepositorySQL struct {
	db *sql.DB
}

// NewUserServiceRepositorySQL creates a new SQL repository.
func NewUserServiceRepositorySQL(db *sql.DB) *UserServiceRepositorySQL {
	return &UserServiceRepositorySQL{db: db}
}


// Register implements the Register operation.
// WARNING: No stored procedure mapping found
func (r *UserServiceRepositorySQL) Register(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error) {
	// TODO: Implement - no matching stored procedure found
	// Consider creating a stored procedure or implementing inline SQL
	return nil, fmt.Errorf("Register: not implemented - no stored procedure mapping")
}


// Login implements the Login operation.
// Mapped to: usp_Login (confidence: 75%, exact match: usp_Login)
func (r *UserServiceRepositorySQL) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) {
	// Execute stored procedure and scan results
	query := "EXEC usp_Login @Email, @PasswordHash"
	row := r.db.QueryRowContext(ctx, query, req.Email, nil)
	var result LoginResponse
	err := row.Scan()
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("Login: not found")
		}
		return nil, fmt.Errorf("Login: %w", err)
	}
	
	return &result, nil
}


// RefreshToken implements the RefreshToken operation.
// WARNING: No stored procedure mapping found
func (r *UserServiceRepositorySQL) RefreshToken(ctx context.Context, req *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	// TODO: Implement - no matching stored procedure found
	// Consider creating a stored procedure or implementing inline SQL
	return nil, fmt.Errorf("RefreshToken: not implemented - no stored procedure mapping")
}


// VerifyEmail implements the VerifyEmail operation.
// Mapped to: usp_VerifyEmail (confidence: 100%, exact match: usp_VerifyEmail)
func (r *UserServiceRepositorySQL) VerifyEmail(ctx context.Context, req *VerifyEmailRequest) (*VerifyEmailResponse, error) {
	// Execute stored procedure and scan results
	query := "EXEC usp_VerifyEmail @Token"
	row := r.db.QueryRowContext(ctx, query, req.Token)
	var result VerifyEmailResponse
	err := row.Scan(&result.Success)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("VerifyEmail: not found")
		}
		return nil, fmt.Errorf("VerifyEmail: %w", err)
	}
	
	return &result, nil
}


// GetUser implements the GetUser operation.
// Mapped to: usp_GetUserById (confidence: 95%, get by id pattern)
func (r *UserServiceRepositorySQL) GetUser(ctx context.Context, req *GetUserRequest) (*GetUserResponse, error) {
	// Execute stored procedure and scan results
	query := "EXEC usp_GetUserById @UserId"
	row := r.db.QueryRowContext(ctx, query, req.ID)
	var nested User
	err := row.Scan(&nested.ID, &nested.Email, &nested.Username, &nested.FirstName, &nested.LastName, &nested.Phone, &nested.IsActive, &nested.EmailVerified, &nested.CreatedAt, &nested.UpdatedAt)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("GetUser: not found")
		}
		return nil, fmt.Errorf("GetUser: %w", err)
	}
	
	return &GetUserResponse{
		User: &nested,
	}, nil
}


// GetUserByEmail implements the GetUserByEmail operation.
// Mapped to: usp_GetUserByEmail (confidence: 100%, exact match: usp_GetUserByEmail)
func (r *UserServiceRepositorySQL) GetUserByEmail(ctx context.Context, req *GetUserByEmailRequest) (*GetUserByEmailResponse, error) {
	// Execute stored procedure and scan results
	query := "EXEC usp_GetUserByEmail @Email"
	row := r.db.QueryRowContext(ctx, query, req.Email)
	var nested User
	err := row.Scan(&nested.ID, &nested.Email, &nested.Username, &nested.FirstName, &nested.LastName, &nested.Phone, &nested.IsActive, &nested.EmailVerified, &nested.CreatedAt, &nested.UpdatedAt)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("GetUserByEmail: not found")
		}
		return nil, fmt.Errorf("GetUserByEmail: %w", err)
	}
	
	return &GetUserByEmailResponse{
		User: &nested,
	}, nil
}


// UpdateUser implements the UpdateUser operation.
// Mapped to: usp_UpdateUser (confidence: 100%, exact match: usp_UpdateUser)
func (r *UserServiceRepositorySQL) UpdateUser(ctx context.Context, req *UpdateUserRequest) (*UpdateUserResponse, error) {
	// Execute stored procedure and scan results
	query := "EXEC usp_UpdateUser @UserId, @FirstName, @LastName, @Phone"
	row := r.db.QueryRowContext(ctx, query, req.ID, req.FirstName, req.LastName, req.Phone)
	var nested User
	err := row.Scan(&nested.ID, &nested.Email, &nested.Username, &nested.FirstName, &nested.LastName, &nested.Phone, &nested.IsActive, &nested.EmailVerified, &nested.CreatedAt, &nested.UpdatedAt)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("UpdateUser: not found")
		}
		return nil, fmt.Errorf("UpdateUser: %w", err)
	}
	
	return &UpdateUserResponse{
		User: &nested,
	}, nil
}


// ChangePassword implements the ChangePassword operation.
// Mapped to: usp_ChangePassword (confidence: 62%, exact match: usp_ChangePassword)
func (r *UserServiceRepositorySQL) ChangePassword(ctx context.Context, req *ChangePasswordRequest) (*ChangePasswordResponse, error) {
	// Execute stored procedure and scan results
	query := "EXEC usp_ChangePassword @UserId, @CurrentPasswordHash, @NewPasswordHash, @NewSalt"
	row := r.db.QueryRowContext(ctx, query, req.UserID, nil, nil, nil)
	var result ChangePasswordResponse
	err := row.Scan(&result.Success)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("ChangePassword: not found")
		}
		return nil, fmt.Errorf("ChangePassword: %w", err)
	}
	
	return &result, nil
}


// DeactivateUser implements the DeactivateUser operation.
// Mapped to: usp_DeactivateUser (confidence: 100%, exact match: usp_DeactivateUser)
func (r *UserServiceRepositorySQL) DeactivateUser(ctx context.Context, req *DeactivateUserRequest) (*DeactivateUserResponse, error) {
	// Execute stored procedure and scan results
	query := "EXEC usp_DeactivateUser @UserId, @Reason"
	row := r.db.QueryRowContext(ctx, query, req.ID, req.Reason)
	var result DeactivateUserResponse
	err := row.Scan(&result.Success)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("DeactivateUser: not found")
		}
		return nil, fmt.Errorf("DeactivateUser: %w", err)
	}
	
	return &result, nil
}


// ============================================================================
// UserService Server
// ============================================================================

// UserServiceServer implements the UserService gRPC service.
type UserServiceServer struct {
	repo UserServiceRepository
}

// NewUserServiceServer creates a new server.
func NewUserServiceServer(repo UserServiceRepository) *UserServiceServer {
	return &UserServiceServer{repo: repo}
}


// Register handles the Register RPC.
func (s *UserServiceServer) Register(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error) {
	return s.repo.Register(ctx, req)
}

// Login handles the Login RPC.
func (s *UserServiceServer) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) {
	return s.repo.Login(ctx, req)
}

// RefreshToken handles the RefreshToken RPC.
func (s *UserServiceServer) RefreshToken(ctx context.Context, req *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	return s.repo.RefreshToken(ctx, req)
}

// VerifyEmail handles the VerifyEmail RPC.
func (s *UserServiceServer) VerifyEmail(ctx context.Context, req *VerifyEmailRequest) (*VerifyEmailResponse, error) {
	return s.repo.VerifyEmail(ctx, req)
}

// GetUser handles the GetUser RPC.
func (s *UserServiceServer) GetUser(ctx context.Context, req *GetUserRequest) (*GetUserResponse, error) {
	return s.repo.GetUser(ctx, req)
}

// GetUserByEmail handles the GetUserByEmail RPC.
func (s *UserServiceServer) GetUserByEmail(ctx context.Context, req *GetUserByEmailRequest) (*GetUserByEmailResponse, error) {
	return s.repo.GetUserByEmail(ctx, req)
}

// UpdateUser handles the UpdateUser RPC.
func (s *UserServiceServer) UpdateUser(ctx context.Context, req *UpdateUserRequest) (*UpdateUserResponse, error) {
	return s.repo.UpdateUser(ctx, req)
}

// ChangePassword handles the ChangePassword RPC.
func (s *UserServiceServer) ChangePassword(ctx context.Context, req *ChangePasswordRequest) (*ChangePasswordResponse, error) {
	return s.repo.ChangePassword(ctx, req)
}

// DeactivateUser handles the DeactivateUser RPC.
func (s *UserServiceServer) DeactivateUser(ctx context.Context, req *DeactivateUserRequest) (*DeactivateUserResponse, error) {
	return s.repo.DeactivateUser(ctx, req)
}

