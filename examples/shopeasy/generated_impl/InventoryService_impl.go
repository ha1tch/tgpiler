// Code generated by tgpiler. DO NOT EDIT.
// Source: proto definitions + stored procedures

package Inventory

import (
	"context"
	"database/sql"
	"fmt"
)

// ============================================================================
// InventoryService Repository Implementation
// ============================================================================

// InventoryServiceRepository defines the data access interface for InventoryService.
type InventoryServiceRepository interface {
	GetInventoryLevel(ctx context.Context, req *GetInventoryLevelRequest) (*GetInventoryLevelResponse, error)
	ListInventoryLevels(ctx context.Context, req *ListInventoryLevelsRequest) (*ListInventoryLevelsResponse, error)
	AdjustInventory(ctx context.Context, req *AdjustInventoryRequest) (*AdjustInventoryResponse, error)
	ReserveInventory(ctx context.Context, req *ReserveInventoryRequest) (*ReserveInventoryResponse, error)
	ReleaseInventory(ctx context.Context, req *ReleaseInventoryRequest) (*ReleaseInventoryResponse, error)
	SetReorderPoint(ctx context.Context, req *SetReorderPointRequest) (*SetReorderPointResponse, error)
	ListTransactions(ctx context.Context, req *ListTransactionsRequest) (*ListTransactionsResponse, error)
	GetLowStockProducts(ctx context.Context, req *GetLowStockProductsRequest) (*GetLowStockProductsResponse, error)
}

// InventoryServiceRepositorySQL implements InventoryServiceRepository using stored procedures.
type InventoryServiceRepositorySQL struct {
	db *sql.DB
}

// NewInventoryServiceRepositorySQL creates a new SQL repository.
func NewInventoryServiceRepositorySQL(db *sql.DB) *InventoryServiceRepositorySQL {
	return &InventoryServiceRepositorySQL{db: db}
}


// GetInventoryLevel implements the GetInventoryLevel operation.
// Mapped to: usp_GetInventoryLevel (confidence: 100%, exact match: usp_GetInventoryLevel)
func (r *InventoryServiceRepositorySQL) GetInventoryLevel(ctx context.Context, req *GetInventoryLevelRequest) (*GetInventoryLevelResponse, error) {
	// Execute stored procedure and scan results
	query := "EXEC usp_GetInventoryLevel @ProductId"
	row := r.db.QueryRowContext(ctx, query, req.ProductID)
	
	var result InventoryLevelResponse
	err := row.Scan()
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("GetInventoryLevel: not found")
		}
		return nil, fmt.Errorf("GetInventoryLevel: %w", err)
	}
	
	return &GetInventoryLevelResponse{
		InventoryLevelResponse: &result,
	}, nil
}


// ListInventoryLevels implements the ListInventoryLevels operation.
// Mapped to: usp_ListInventoryLevels (confidence: 75%, exact match: usp_ListInventoryLevels)
func (r *InventoryServiceRepositorySQL) ListInventoryLevels(ctx context.Context, req *ListInventoryLevelsRequest) (*ListInventoryLevelsResponse, error) {
	// Execute stored procedure and scan results
	query := "EXEC usp_ListInventoryLevels @LowStockOnly, @OutOfStockOnly, @CategoryId"
	row := r.db.QueryRowContext(ctx, query, req.LowStockOnly, req.OutOfStockOnly, req.CategoryID)
	
	var result ListInventoryLevelsResponse
	err := row.Scan()
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("ListInventoryLevels: not found")
		}
		return nil, fmt.Errorf("ListInventoryLevels: %w", err)
	}
	
	return &ListInventoryLevelsResponse{
	}, nil
}


// AdjustInventory implements the AdjustInventory operation.
// Mapped to: usp_AdjustInventory (confidence: 100%, exact match: usp_AdjustInventory)
func (r *InventoryServiceRepositorySQL) AdjustInventory(ctx context.Context, req *AdjustInventoryRequest) (*AdjustInventoryResponse, error) {
	// Execute stored procedure (no result mapping)
	query := "EXEC usp_AdjustInventory @ProductId, @QuantityChange, @Reason, @Reference, @Notes, @AdjustedBy"
	_, err := r.db.ExecContext(ctx, query, req.ProductID, req.QuantityChange, req.Reason, req.Reference, req.Notes, req.AdjustedBy)
	if err != nil {
		return nil, fmt.Errorf("AdjustInventory: %w", err)
	}
	
	return &AdjustInventoryResponse{}, nil
}


// ReserveInventory implements the ReserveInventory operation.
// Mapped to: usp_ReserveInventory (confidence: 100%, exact match: usp_ReserveInventory)
func (r *InventoryServiceRepositorySQL) ReserveInventory(ctx context.Context, req *ReserveInventoryRequest) (*ReserveInventoryResponse, error) {
	// Execute stored procedure and scan results
	query := "EXEC usp_ReserveInventory @OrderId, @Items"
	row := r.db.QueryRowContext(ctx, query, req.OrderID, req.Items)
	
	var result ReserveInventoryResponse
	err := row.Scan()
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("ReserveInventory: not found")
		}
		return nil, fmt.Errorf("ReserveInventory: %w", err)
	}
	
	return &ReserveInventoryResponse{
	}, nil
}


// ReleaseInventory implements the ReleaseInventory operation.
// Mapped to: usp_ReleaseInventory (confidence: 100%, exact match: usp_ReleaseInventory)
func (r *InventoryServiceRepositorySQL) ReleaseInventory(ctx context.Context, req *ReleaseInventoryRequest) (*ReleaseInventoryResponse, error) {
	// Execute stored procedure (no result mapping)
	query := "EXEC usp_ReleaseInventory @OrderId"
	_, err := r.db.ExecContext(ctx, query, req.OrderID)
	if err != nil {
		return nil, fmt.Errorf("ReleaseInventory: %w", err)
	}
	
	return &ReleaseInventoryResponse{}, nil
}


// SetReorderPoint implements the SetReorderPoint operation.
// Mapped to: usp_SetReorderPoint (confidence: 100%, exact match: usp_SetReorderPoint)
func (r *InventoryServiceRepositorySQL) SetReorderPoint(ctx context.Context, req *SetReorderPointRequest) (*SetReorderPointResponse, error) {
	// Execute stored procedure (no result mapping)
	query := "EXEC usp_SetReorderPoint @ProductId, @ReorderPoint, @ReorderQuantity"
	_, err := r.db.ExecContext(ctx, query, req.ProductID, req.ReorderPoint, req.ReorderQuantity)
	if err != nil {
		return nil, fmt.Errorf("SetReorderPoint: %w", err)
	}
	
	return &SetReorderPointResponse{}, nil
}


// ListTransactions implements the ListTransactions operation.
// WARNING: No stored procedure mapping found
func (r *InventoryServiceRepositorySQL) ListTransactions(ctx context.Context, req *ListTransactionsRequest) (*ListTransactionsResponse, error) {
	// TODO: Implement - no matching stored procedure found
	// Consider creating a stored procedure or implementing inline SQL
	return nil, fmt.Errorf("ListTransactions: not implemented - no stored procedure mapping")
}


// GetLowStockProducts implements the GetLowStockProducts operation.
// Mapped to: usp_GetLowStockProducts (confidence: 75%, exact match: usp_GetLowStockProducts)
func (r *InventoryServiceRepositorySQL) GetLowStockProducts(ctx context.Context, req *GetLowStockProductsRequest) (*GetLowStockProductsResponse, error) {
	// Execute stored procedure and scan results
	query := "EXEC usp_GetLowStockProducts @ThresholdPercentage"
	row := r.db.QueryRowContext(ctx, query, req.ThresholdPercentage)
	
	var result LowStockProductsResponse
	err := row.Scan()
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("GetLowStockProducts: not found")
		}
		return nil, fmt.Errorf("GetLowStockProducts: %w", err)
	}
	
	return &GetLowStockProductsResponse{
		LowStockProductsResponse: &result,
	}, nil
}


// ============================================================================
// InventoryService Server
// ============================================================================

// InventoryServiceServer implements the InventoryService gRPC service.
type InventoryServiceServer struct {
	repo InventoryServiceRepository
}

// NewInventoryServiceServer creates a new server.
func NewInventoryServiceServer(repo InventoryServiceRepository) *InventoryServiceServer {
	return &InventoryServiceServer{repo: repo}
}


// GetInventoryLevel handles the GetInventoryLevel RPC.
func (s *InventoryServiceServer) GetInventoryLevel(ctx context.Context, req *GetInventoryLevelRequest) (*GetInventoryLevelResponse, error) {
	return s.repo.GetInventoryLevel(ctx, req)
}

// ListInventoryLevels handles the ListInventoryLevels RPC.
func (s *InventoryServiceServer) ListInventoryLevels(ctx context.Context, req *ListInventoryLevelsRequest) (*ListInventoryLevelsResponse, error) {
	return s.repo.ListInventoryLevels(ctx, req)
}

// AdjustInventory handles the AdjustInventory RPC.
func (s *InventoryServiceServer) AdjustInventory(ctx context.Context, req *AdjustInventoryRequest) (*AdjustInventoryResponse, error) {
	return s.repo.AdjustInventory(ctx, req)
}

// ReserveInventory handles the ReserveInventory RPC.
func (s *InventoryServiceServer) ReserveInventory(ctx context.Context, req *ReserveInventoryRequest) (*ReserveInventoryResponse, error) {
	return s.repo.ReserveInventory(ctx, req)
}

// ReleaseInventory handles the ReleaseInventory RPC.
func (s *InventoryServiceServer) ReleaseInventory(ctx context.Context, req *ReleaseInventoryRequest) (*ReleaseInventoryResponse, error) {
	return s.repo.ReleaseInventory(ctx, req)
}

// SetReorderPoint handles the SetReorderPoint RPC.
func (s *InventoryServiceServer) SetReorderPoint(ctx context.Context, req *SetReorderPointRequest) (*SetReorderPointResponse, error) {
	return s.repo.SetReorderPoint(ctx, req)
}

// ListTransactions handles the ListTransactions RPC.
func (s *InventoryServiceServer) ListTransactions(ctx context.Context, req *ListTransactionsRequest) (*ListTransactionsResponse, error) {
	return s.repo.ListTransactions(ctx, req)
}

// GetLowStockProducts handles the GetLowStockProducts RPC.
func (s *InventoryServiceServer) GetLowStockProducts(ctx context.Context, req *GetLowStockProductsRequest) (*GetLowStockProductsResponse, error) {
	return s.repo.GetLowStockProducts(ctx, req)
}

